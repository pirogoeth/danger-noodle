package havabol.parse;

import havabol.Token;
import havabol.Scanner;
import havabol.classify.*;
import havabol.sym.*;
import havabol.util.*;
import static havabol.util.Precedence.rebuildWithPrecedence;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Parses tokens.
 *
 * @author Sean Johnson <isr830@my.utsa.edu>
 */
public class Parser {

    private static final List<String> comparators = Arrays.asList(new String[]{
        "==", "!=", ">=", "<=", ">", "<",
    });

    /**
     * Checks the primary and subclass type of the given token.
     *
     * @param Token t token to check
     * @param Primary p primary class
     * @param Subclass s subclass
     *
     * @return boolean
     */
    static boolean tokenType(Token t, Primary p, Subclass s) {
        if ( p == null ) p = Primary.UNKNOWN;
        if ( s == null ) s = Subclass.UNKNOWN;

        return t.primClassif == p.getCid() && t.subClassif == s.getCid();
    }

    /*
     * List of tokens passed from the language entry stub.
     * Should be generated by the Scanner.
     */
    private List<Token> tokens;

    public Parser(List<Token> tokens) {
        this.tokens = tokens;
    }

    // ERROR MANGLEMENT

    /**
     * Creates and throws a ParserException with a set of context passed
     * from parser blocks.
     *
     * @param String message
     * @param Token[] contexts
     *
     * @return void
     *
     * @throws ParserException
     */
    static void reportParseError(String message, Token...contexts) throws ParserException {
        String[] contextStr = new String[contexts.length];

        for (int i = 0; i < contextStr.length; i++) {
            Token t = contexts[i];
            if ( t != null ) {
                contextStr[i] = String.format(
                        "[%s:%d:%d]: Near token `%s`",
                        Scanner.getInstance().sourceFileNm,
                        t.iSourceLineNr,
                        t.iColPos,
                        t.tokenStr
                );
            } else {
                contextStr[i] = "[invalid] Null token given to error reporter";
            }
        }

        StringBuilder excSb = new StringBuilder();

        for (String s : contextStr) {
            excSb.append(s + "\n");
        }

        throw new ParserException(
                String.format(
                    "Parse error occurred: %s\n%s",
                    message,
                    excSb
                ),
                contexts
        );
    }

    // TOKEN MANGLEMENT

    // def isNext.

    /**
     * Check the string value of the next token.
     *
     * @param String s
     *
     * @return boolean
     */
    private boolean isNext(String s) {
        return this.isNext(this.tokens, s);
    }

    /**
     * Check the string value of the next token inside the token subset in `t`.
     *
     * @param List<Token> t
     * @param String s
     *
     * @return boolean
     */
    private boolean isNext(List<Token> tokens, String s) {
        Token t = this.peekNext(tokens);
        if ( t == null ) {
            return false;
        }

        if ( t.tokenStr.equals(s) ) {
            return true;
        }

        return false;
    }

    // def eatNext.

    /**
     * Forces the parser to eat the next token.
     *
     * @return void
     */
    private void eatNext() {
        this.tokens.remove(0);
    }

    /**
     * Forces the parser to eat the next token from the token subset in `l`.
     *
     * @return void
     */
    private void eatNext(List<Token> l) {
        l.remove(0);
    }

    // def eatNextIfOfType.

    /**
     * Forces the parser to eat the next token if the token's primary and
     * sub classes match the given type.
     *
     * @param Primary prim
     * @param Subclass sub
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfOfType(Primary prim, Subclass sub) {
        return this.eatNextIfOfType(this.tokens, prim, sub);
    }

    /**
     * Forces the parser to eat the next token from the token subset at `l`
     * if the token's primary and sub classes match the given type.
     *
     * @param List<Token> l
     * @param Primary prim
     * @param Subclass sub
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfOfType(List<Token> l, Primary prim, Subclass sub) {
        if ( tokenType(this.peekNext(l), prim, sub) ) {
            this.eatNext(l);
            return true;
        }

        return false;
    }

    // def eatNextIfEq.

    /**
     * Forces the parser to eat the next token if the token's string value
     * matches the given string value.
     *
     * @param String s
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfEq(String s) {
        return this.eatNextIfEq(this.tokens, s);
    }

    /**
     * Forces the parser to eat the next token from the token subset at `l`
     * if the token's string value matches the given string value.
     *
     * @param List<Token> l
     * @param String s
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfEq(List<Token> l, String s) {
        if ( this.isNext(l, s) ) {
            this.eatNext(l);
            return true;
        }

        return false;
    }

    // def popNext.

    /**
     * Pops the next token off the array.
     *
     * @return Token
     */
    private Token popNext() {
        return this.popNext(this.tokens);
    }

    private Token popNext(List<Token> l) {
        if ( l.isEmpty() ) {
            return null;
        }

        return l.remove(0);
    }

    // def peekNext.

    /**
     * Allows for single lookahead of the next token without popping.
     *
     * @return Token
     */
    private Token peekNext() {
        try {
            return this.tokens.get(0);
        } catch (IndexOutOfBoundsException ex) {
            return null;
        }
    }

    private Token peekNext(List<Token> l) {
        try {
            return l.get(0);
        } catch (IndexOutOfBoundsException ex) {
            return null;
        }
    }

    // def popStatement.

    /**
     * Gets and returns a list of tokens up to statement end.
     *
     * @return List<Token>
     */
    private List<Token> popStatement() {
        return this.popStatement(this.tokens);
    }

    /**
     * Gets and returns a list of tokens up to statement end.
     *
     * @return List<Token>
     */
    private List<Token> popStatement(List<Token> tokens) {
        List<Token> newTokens = this.popUntil(tokens, ";");

        this.eatNext();

        return newTokens;
    }

    // def popUntil.

    /**
     * Gets and returns a list of tokens up to the next delimiter.
     *
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntil(String delim) {
        return this.popUntil(this.tokens, delim);
    }

    /**
     * Gets and returns a list of tokens up to the next delimiter.
     *
     * @param List<Token> tokens
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntil(List<Token> tokens, String delim) {
        List<Token> newTokens = new ArrayList<>();

        Token t;
        while ( (t = this.peekNext(tokens)) != null && ! t.tokenStr.equals(delim) ) {
            newTokens.add(this.popNext(tokens));
        }

        return newTokens;
    }

    /**
     * Gets and returns a list of tokens up to the next set of delimiters.
     *
     * @param String delims
     *
     * @return List<Token>
     */
    private List<Token> popUntil(String...delims) {
        return this.popUntil(this.tokens, delims);
    }

    /**
     * Gets and returns a list of tokens up to the next set of delimiters.
     *
     * @param List<Token> tokens
     * @param String delims
     *
     * @return List<Token>
     */
    private List<Token> popUntil(List<Token> tokens, String...delims) {
        List<Token> newTokens = new ArrayList<>();

        List<String> delimsList = Arrays.asList(delims);

        Token t;
        while ( (t = this.peekNext(tokens)) != null && ! delimsList.contains(t.tokenStr) ) {
            newTokens.add(this.popNext(tokens));
        }

        return newTokens;
    }

    // def popUntilLast.

    /**
     * Pops until the last occurrence of a token.
     *
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntilLast(String delim) {
        return this.popUntilLast(this.tokens, delim);
    }

    /**
     * Pops until the last occurrence of a token.
     *
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntilLast(List<Token> tokens, String delim) {
        List<Token> newTokens = new ArrayList<>();

        int idx = tokens.size() - 1;
        for ( ; idx >= 0; idx-- ) {
            if ( tokens.get(idx).tokenStr.equals(delim) ) {
                break;
            }
        }

        for ( int i = 0; i < idx; i++ ) {
            newTokens.add(this.popNext(tokens));
        }

        return newTokens;
    }

    // def popUntilMatch.

    /**
     * Pops until a match is found for the string value of the current token.
     * Current token may have one of the following values: [ (
     *
     * @return List<Token>
     */
    private List<Token> popUntilMatch() {
        return this.popUntilMatch(this.tokens);
    }

    /**
     * Pops until a match is found for the string value of the current token.
     * Current token may have one of the following values: [ (
     *
     * @return List<Token>
     */
    private List<Token> popUntilMatch(List<Token> tokens) {
        Token cur = this.peekNext(tokens);
        if ( cur == null ) {
            return null;
        }

        return this.popUntilMatch(tokens, cur.tokenStr);
    }

    /**
     * Pops until the matching occurrence of a closer for a token set.
     * Bracket may be one of: [ (
     *
     * @param String bracket
     *
     * @return List<Token>
     */
    private List<Token> popUntilMatch(String bracket) {
        return this.popUntilMatch(this.tokens, bracket);
    }

    /**
     * Pops until the matching occurrence of a closer for a token set.
     * Bracket may be one of: [ (
     *
     * @param List<Token> tokens
     * @param String bracket
     *
     * @return List<Token>
     */
    private List<Token> popUntilMatch(List<Token> tokens, String bracket) {
        List<Token> newTokens = new ArrayList<>();
        Map<String, String> sets = new HashMap<>();
        sets.put("(", ")");
        sets.put("[", "]");

        int bCount = 0;

        // First iteration here should always put bCount at 1.
        Token t;
        while ( this.canParse(tokens) ) {
            t = this.popNext(tokens);

            if ( t.tokenStr.equals(bracket) ) {
                bCount++;
            } else if ( t.tokenStr.equals(sets.get(bracket)) ) {
                bCount--;
            }

            newTokens.add(t);

            if ( bCount == 0 ) {
                break;
            }
        }

        return newTokens;
    }

    // def eatOuterMatching.

    /**
     * Eats the first matching outer tokens to strip away into the inner expression.
     * Current token may have one of the following values: [ (
     *
     * @return List<Token>
     */
    private List<Token> eatOuterMatching() {
        return this.eatOuterMatching(this.tokens);
    }

    /**
     * Eats the first matching outer tokens to strip away into the inner expression.
     * Current token may have one of the following values: [ (
     *
     * @param List<Token> tokens
     *
     * @return List<Token>
     */
    private List<Token> eatOuterMatching(List<Token> tokens) {
        List<Token> newTokens = new ArrayList<>();
        newTokens.addAll(tokens);

        Map<String, String> sets = new HashMap<>();
        sets.put("(", ")");
        sets.put("[", "]");

        Token begin = this.peekNext(tokens);
        Token end = tokens.get(tokens.size() - 1);
        for (Map.Entry entry : sets.entrySet()) {
            if ( begin.tokenStr.equals(entry.getKey()) && end.tokenStr.equals(entry.getValue()) ) {
                newTokens.remove(newTokens.size() - 1);
                newTokens.remove(0);

                return newTokens;
            }
        }

        return newTokens;
    }

    // def containsToken.

    /**
     * Determines whether or not a tokens list contains the String value.
     *
     * @param String value
     *
     * @return boolean
     */
    private boolean containsToken(String value) {
        return this.containsToken(this.tokens, value);
    }

    /**
     * Determines whether or not a tokens list contains the String value.
     *
     * @param List<Token> tokens
     * @param String value
     *
     * @return boolean
     */
    private boolean containsToken(List<Token> tokens, String value) {
        for (Token t : tokens) {
            if ( t.tokenStr.equals(value) ) {
                return true;
            }
        }

        return false;
    }

    // PARSER MANGLEMENT

    // def canParse.

    /**
     * Returns if the parser's internal token list is empty or not.
     *
     * @return boolean
     */
    public boolean canParse() {
        return this.canParse(this.tokens);
    }

    public boolean canParse(List<Token> tokens) {
        return !tokens.isEmpty();
    }

    /**
     * Public parsing entrypoint. Returns a single parsed statement
     * in a mini-AST form.
     *
     * @return Statement
     *
     * @throws ParserException
     */
    public Statement parse() throws ParserException {
        Token t = this.peekNext();

        if ( t.tokenStr.equalsIgnoreCase("debug") ) {
            this.handleDebug(this.popStatement());
            return new Statement();
        }

        Expression expr = null;
        switch (Primary.primaryFromInt(t.primClassif)) {
            case CONTROL:
                return this.parseControl(t);
            case OPERAND:
                expr = this.parseExpression(this.popStatement());
                if ( !expr.isValid() ) {
                    // Expr not valid?
                    return null;
                }

                return new Statement(expr);
            case FUNCTION:
                FunctionCall funcCall = this.parseFunctionCall(this.popStatement());
                if ( !funcCall.isValid() ) {
                    // Function call not valid?
                    return null;
                }

                // Up-resolve to expression
                expr = new Expression(funcCall);
                if ( !expr.isValid() ) {
                    // ..
                    return null;
                }

                return new Statement(expr);
            case SEPARATOR:
                return null;
            default:
                reportParseError(
                        "Could not further derive statement",
                        t
                );
                return null;
        }
    }

    /**
     * Parses a control statement based on the leading token.
     * Allows declarations, "for", "while", "if", and "select",
     * as well as their corresponding "end" statements.
     *
     * @param Token head
     *
     * @return Statement
     *
     * @throws ParserException
     */
    private Statement parseControl(Token head) throws ParserException {
        switch (Subclass.subclassFromInt(head.subClassif)) {
            case FLOW:
                return new Statement(this.parseFlowControl(this.popUntil(":")));
            case END:
                return null;
            case DECLARE:
                this.eatNext();
                return this.parseDeclaration(head);
            default:
                reportParseError(
                        "Failed building control elements",
                        head
                );
                return null;
        }

    }

    /**
     * Parses a full flow control statement until its corresponding end
     * statement.
     *
     * @param List<Token> tokens
     *
     * @return FlowControl
     *
     * @throws ParserException
     */
    private FlowControl parseFlowControl(List<Token> tokens) throws ParserException {
        // At this point, the next token should be the flow delimiter.
        this.eatNextIfEq(":");

        Token flowT = this.popNext(tokens);

        Expression cond;
        Block mainBranch;
        switch (flowT.tokenStr) {
            case "if":
                cond = this.parseExpression(tokens);
                mainBranch = this.parseBlock("else", "endif");
                Block elseBranch = null;

                if ( this.isNext("else") ) {
                    this.eatNext();
                    this.eatNextIfEq(":");
                    elseBranch = this.parseBlock("endif");
                }

                if ( ! this.eatNextIfEq("endif") ) {
                    reportParseError(
                            "If statement has no matching endif",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                IfControl ifStmt = new IfControl(cond, mainBranch, elseBranch);
                return new FlowControl(ifStmt);
            case "while":
                cond = this.parseExpression(tokens);
                mainBranch = this.parseBlock("endwhile");

                if ( ! this.eatNextIfEq("endwhile") ) {
                    reportParseError(
                            "While statement has no matching endwhile",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                WhileControl whileStmt = new WhileControl(cond, mainBranch);
                return new FlowControl(whileStmt);
            case "for":
                ForExpr expr = this.parseForExpr(tokens);

                Block forBody = this.parseBlock("endfor");
                if ( ! this.eatNextIfEq("endfor") ) {
                    reportParseError(
                            "While statement has no matching endfor",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                ForControl forStmt = new ForControl(expr, forBody);
                return new FlowControl(forStmt);
            case "select":
                // do the thing
                break;
            default:
                // wat
                reportParseError(
                        "Invalid control flow token",
                        flowT
                );
                return null;
        }

        reportParseError(
                "Flow control parser fell out of case",
                flowT
        );
        return null;
    }

    /**
     * Parses a declaration given the starting datatype token.
     *
     * @param Token head
     *
     * @return Statement
     *
     * @throws ParserException
     */
    private Statement parseDeclaration(Token head) throws ParserException {
        List<Token> tokens = this.popStatement();

        DataType dt = new DataType(head);

        Token identT = this.popNext(tokens);
        Identifier ident = new Identifier(identT);

        Declaration decl;

        Subscript sub;
        Token tmp = this.peekNext(tokens);

        if ( tmp != null && tmp.tokenStr.equals("[") ) {
            List<Token> aryDesc = this.eatOuterMatching(this.popUntilMatch(tokens));
            if ( this.peekNext(aryDesc) != null && this.peekNext(aryDesc).tokenStr.equals("unbound") ) {
                // unbounded
                decl = new Declaration(dt, ident, true);
            } else {
                // bounding expression
                Expression arySize = this.parseExpression(aryDesc);
                decl = new Declaration(dt, ident, true, arySize);
            }
        } else {
            decl = new Declaration(dt, ident);
        }

        // Peek at the next token to see if this is a compound declaration
        Token operT = this.popNext(tokens);
        if ( operT != null && operT.tokenStr.equals("=") ) {
            Expression expr = this.parseExpression(tokens);

            Assignment a = new Assignment(decl, new Operator(operT), expr);
            if ( a == null || !a.isValid() ) {
                reportParseError(
                        "Declaration is invalid",
                        head,
                        identT,
                        operT
                );
                return null;
            }

            return new Statement(a);
        }

        if ( decl.isValid() ) {
            return new Statement(decl);
        } else {
            reportParseError(
                    "Declaration is invalid",
                    head,
                    identT,
                    operT
            );
            return null;
        }
    }

    /**
     * Parses a function call plus the arguments, which get reduced to
     * individual `Expression`s.
     *
     * @param List<Token> tokens
     *
     * @return FunctionCall
     *
     * @throws ParserException
     */
    private FunctionCall parseFunctionCall(List<Token> tokens) throws ParserException {
        Token handle = this.popNext(tokens);

        Identifier funcName = new Identifier(handle);
        if ( !funcName.isValid() ) {
            reportParseError(
                    "Bad function handle",
                    handle
            );
            return null;
        }

        tokens = this.eatOuterMatching(tokens);

        List<Expression> argsList = new ArrayList<>();

        List<Token> exprBuf = new ArrayList<>();
        while ( this.canParse(tokens) ) {
            Token cur = this.peekNext(tokens);
            switch (Primary.primaryFromInt(cur.primClassif)) {
                case SEPARATOR:
                    this.eatNextIfEq(tokens, ",");
                default:
                    exprBuf = this.popUntil(tokens, ",");
                    break;
            }

            if ( exprBuf == null ) {
                reportParseError(
                    "Expression buffer is null - this should not happen!",
                    handle
                );
                return null;
            }

            argsList.add(this.parseExpression(exprBuf));
            exprBuf = new ArrayList<>();
        }

        FunctionCall fCall = new FunctionCall(funcName, argsList);
        if ( !fCall.isValid() ) {
            reportParseError(
                    "Invalid function call",
                    handle
            );
            return null;
        }

        return fCall;
    }

    /**
     * Parse a block from the parser's token list. Will parse up to
     * delimiter(s) given in `...until`.
     *
     * @param String[] until
     *
     * @return Block
     *
     * @throws ParserException
     */
    private Block parseBlock(String...until) throws ParserException {
        return this.parseBlock(this.tokens, until);
    }

    /**
     * Parse a block from an arbitrary token list. Will parse up to
     * delimiter(s) given in `...until`.
     *
     * @param String[] until
     *
     * @return Block
     *
     * @throws ParserException
     */
    private Block parseBlock(List<Token> tokens, String...until) throws ParserException {
        List<String> delim = Arrays.asList(until);
        List<Statement> stmts = new ArrayList<>();

        while ( ! delim.contains(this.peekNext(tokens).tokenStr) ) {
            Statement s = this.parse();
            if ( s == null ) {
                reportParseError(
                        "Block parser encountered a null statement",
                        this.peekNext(tokens)
                );
                break;
            }
            stmts.add(s);
        }

        return new Block(stmts);
    }

    /**
     * Parses an expression from a list of tokens. Most general case token
     * reduction available underneath `Statement`.
     *
     * @param List<Token> arg
     *
     * @return Expression
     *
     * @throws ParserException
     */
    private Expression parseExpression(List<Token> arg) throws ParserException {
        if ( arg.isEmpty() ) {
            reportParseError("Expression parsing failed - empty token list!");
            return null;
        }

        Token head = this.popNext(arg);
        if ( arg.isEmpty() ) {
            return new Expression(head);
        }

        Token next = this.peekNext(arg);

        List<Token> buf = new ArrayList<>();
        switch (Primary.primaryFromInt(head.primClassif)) {
            case OPERATOR:
                // Begins with an operator, parse into UnaryOperator
                Operator op = new Operator(head);
                Expression exprNg = this.parseExpression(arg);

                UnaryOperation unOp = new UnaryOperation(op, exprNg);
                if ( ! unOp.isValid() ) {
                    reportParseError(
                        "Invalid unary operation",
                        head,
                        next
                    );
                    return null;
                }

                return new Expression(unOp);
            case OPERAND:
                if ( next.primClassif == Primary.OPERATOR.getCid() ) {
                    Expression lhs = new Expression(head);
                    Operator oper = new Operator(this.popNext(arg));
                    Expression rhs = this.parseExpression(arg);

                    BinaryOperation binOp;
                    BinaryOperation tmp;

                    // If rhs is comparative operation, we *MUST* do some magical tree hoisting.
                    // RHS will be newCur if it has a comparator
                    BinaryOperation rhsOp = rhs.getBinaryOperation();
                    if ( rhsOp != null && comparators.contains(rhsOp.getOper().getOperator()) ) {
                        // The the RHS contains a comparator, hoist it up
                        // grab the LHS of the RHS operation - that is new RHS of newCur
                        rhs = rhsOp.getLHS();
                        // store off the new LHS of newCur to tmp
                        tmp = new BinaryOperation(lhs, oper, rhs);
                        // create the newCur
                        binOp = new BinaryOperation(new Expression(tmp), rhsOp.getOper(), rhsOp.getRHS());
                    } else {
                        binOp = new BinaryOperation(lhs, oper, rhs);
                    }

                    if ( next.tokenStr.equals("=") ) {
                        // binOp is an assignment
                        Assignment a = new Assignment(binOp);
                        if ( ! a.isValid() ) {
                            reportParseError(
                                "Building assignment failed",
                                head,
                                next
                            );
                            return null;
                        }

                        return new Expression(a);
                    } else {
                        if ( ! binOp.isValid() ) {
                            reportParseError(
                                "Building binary operation failed",
                                head,
                                next
                            );
                            return null;
                        }

                        return new Expression(binOp);
                    }
                } else if ( next.primClassif == Primary.SEPARATOR.getCid() ) {
                    switch (next.tokenStr) {
                        case ",":  // Array notation
                            Array ary = new Array();
                            ary.addItem(new Primitive(head));

                            while ( this.canParse(arg) ) {
                                Token t = this.popNext(arg);
                                switch (Primary.primaryFromInt(t.primClassif)) {
                                    case OPERAND:
                                        ary.addItem(new Primitive(t));
                                        break;
                                    case SEPARATOR:
                                        continue;
                                    default:
                                        reportParseError(
                                            "Invalid token in array construct",
                                            t
                                        );
                                        return null;
                                }
                            }

                            return new Expression(ary);
                        case "[":  // subscripted identifier
                            Subscript sub = this.parseSubscript(arg);

                            Identifier i = new Identifier(head, sub);
                            if ( i.isValid() ) {
                                Expression lhs = new Expression(i);

                                if ( ! this.canParse(arg) ) {
                                    return lhs;
                                }

                                Token operT = this.popNext(arg);
                                Operator oper = new Operator(operT);

                                Expression rhs = this.parseExpression(arg);
                                BinaryOperation binOp = new BinaryOperation(lhs, oper, rhs);

                                if ( operT.tokenStr.equals("=") ) {
                                    // binOp is an assignment
                                    Assignment a = new Assignment(binOp);
                                    if ( ! a.isValid() ) {
                                        reportParseError(
                                            "Building assignment in subscript failed",
                                            head,
                                            next
                                        );
                                        return null;
                                    }

                                    return new Expression(a);
                                } else {
                                    if ( ! binOp.isValid() ) {
                                        reportParseError(
                                            "Building binary operation inside subscript failed",
                                            head,
                                            next
                                        );
                                        return null;
                                    }

                                    return new Expression(binOp);
                                }
                            } else {
                                reportParseError(
                                    "Identifier is not valid",
                                    head,
                                    next
                                );
                                return null;
                            }
                        case "(":  // function call..
                            // this should be a function call since an open paren follows it.
                            // reclassify the head token and build the function call.
                            //
                            // Since it was not recognized by the Scanner as a function call,
                            // it *has* to be a user defined function.
                            head.primClassif = Primary.FUNCTION.getCid();
                            head.subClassif = Subclass.USER.getCid();

                            // Re-call parseExpression to parse the newly known function call!
                            arg.add(0, head);

                            return this.parseExpression(arg);
                        default:
                            break; // doot doot
                    }
                }

                break;
            case FUNCTION:
                buf.add(head);
                buf.addAll(this.popUntilMatch(arg));

                FunctionCall fCall = this.parseFunctionCall(buf);
                if ( ! fCall.isValid() ) {
                    reportParseError(
                            "Building function call from expression failed",
                            head,
                            next
                    );
                    return null;
                }

                Expression fCallExpr = new Expression(fCall);

                next = this.peekNext(arg);

                if ( next != null && next.primClassif == Primary.OPERATOR.getCid() ) {
                    Expression lhs = fCallExpr;
                    Operator oper = new Operator(this.popNext(arg));

                    Expression rhs = this.parseExpression(arg);
                    BinaryOperation binOp = new BinaryOperation(lhs, oper, rhs);

                    if ( ! binOp.isValid() ) {
                        reportParseError(
                                "Building binary operation failed",
                                head,
                                next
                        );
                        return null;
                    }

                    return new Expression(binOp);
                }

                return fCallExpr;
            case SEPARATOR:
                // NOTE: Only valid separator while building an expression is `(` or `)`...
                // `[` and `]` are valid only if used as a subscript on an ident.
                //
                // Separators inside expressions are weird. They can be used to force operation
                // grouping.
                if ( ! head.tokenStr.equals("(") ) {
                    reportParseError(
                        String.format(
                            "Invalid separator inside expression - `%s`",
                            head.tokenStr
                        ),
                        head,
                        next
                    );
                    return null;
                }

                // Rebuild the token buffer
                arg.add(0, head);

                // Pop off the current grouping
                buf.addAll(this.popUntilMatch(arg));

                // Create an expression from the inner grouping
                buf = this.eatOuterMatching(buf);
                Expression grp = this.parseExpression(buf);
                if ( grp.getExpressionType() == ExpressionType.BINARY_OP ) {
                    grp.getBinaryOperation().setExplicitlyGrouped(true);
                }

                next = this.peekNext(arg);

                if ( next != null && next.primClassif == Primary.OPERATOR.getCid() ) {
                    Operator oper = new Operator(this.popNext(arg));

                    Expression rhs = this.parseExpression(arg);
                    BinaryOperation binOp = new BinaryOperation(grp, oper, rhs);

                    if ( ! binOp.isValid() ) {
                        reportParseError(
                                "Building binary operation failed",
                                head,
                                next
                        );
                        return null;
                    }

                    return new Expression(binOp);
                } else {
                    return grp;
                }
            default:
                reportParseError(
                        "Building expression failed",
                        head,
                        next
                );
                return null;
        }

        reportParseError(
                "Expression parser fell out of switch, bailing out",
                head,
                next
        );

        return null;
    }

    private Subscript parseSubscript(List<Token> tokens) throws ParserException {
        List<Token> sArgT = this.eatOuterMatching(this.popUntilMatch(tokens));

        // first upcoming token should be some sort of expression
        // the next delimiter token (`:`) will mark the end of the begin expression
        // of the subscript
        Subscript sub;

        List<Token> exprBeginPartT = this.popUntil(sArgT, ":");
        Expression exprBegin = this.parseExpression(exprBeginPartT);

        Expression exprEnd = null;

        // Depending on the next token, we can create the subscript to attach
        // to the identifier.
        if ( this.eatNextIfEq(sArgT, ":") ) {
            // There's an end part of the subscript!

            // Because `popUntil` actually eats tokens from `sArgT` and
            // `sArgT` has the outer match eaten, we just need the remainder of `sArgT`.
            //   List<Token> exprEndPartT;
            //   exprEndPartT = this.popUntil(sArgT, "]");
            exprEnd = this.parseExpression(sArgT);
        }

        if ( this.peekNext(sArgT) == null ) {
            // Finish the subscript
            sub = new Subscript(exprBegin, exprEnd);
        } else {
            reportParseError(
                String.format(
                    "Unexpected token `%s`, expected end-of-subscript (`]`)",
                    this.peekNext(sArgT)
                ),
                this.peekNext(sArgT)
            );
            return null;
        }

        return sub;
    }

    private ForExpr parseForExpr(List<Token> tokens) throws ParserException {
        Token identT = this.popNext(tokens);
        Identifier ident = new Identifier(identT);
        ForExpr expr = null;

        if ( this.eatNextIfEq(tokens, "=") ) {
            Expression initExpr = this.parseExpression(this.popUntil(tokens, "to"));
            // Next is `to`
            this.eatNext(tokens);
            Expression maxExpr = this.parseExpression(this.popUntil(tokens, "by"));
            // next is `by` - optional
            Expression stepExpr;
            if ( this.eatNextIfEq(tokens, "by") ) {
                stepExpr = this.parseExpression(tokens);
            } else {
                stepExpr = null;
            }

            expr = new ForExpr(ident, initExpr, maxExpr, stepExpr);
        } else if ( this.eatNextIfEq(tokens, "in") ) {
            Expression container = this.parseExpression(tokens);

            expr = new ForExpr(ident, container);
        }

        if ( expr != null && ! expr.isValid() ) {
            reportParseError(
                "For expression is invalid",
                identT
            );
            return null;
        }

        return expr;
    }

    private void handleDebug(List<Token> tokens) throws ParserException {
        Token flagT = this.popNext(tokens);
        Token dbgTypeT = this.popNext(tokens);
        Token valueT = this.popNext(tokens);

        Debug dbg = Debug.get();
        if ( ! dbg.set(dbgTypeT.tokenStr, valueT.tokenStr) ) {
            reportParseError(
                "Could not set debugging flag",
                flagT,
                dbgTypeT,
                valueT
            );
        }
    }

}
