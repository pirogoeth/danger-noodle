package havabol.parse;

import havabol.Token;
import havabol.Scanner;
import havabol.SymbolTable;
import havabol.classify.*;
import havabol.util.*;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * ParserException exposes a series of tokens and a message
 * that can be used to generate context for finding the error
 * inside code.
 */
class ParserException extends Exception {

    public long serialVersionUid = 1000000L;
    private Token[] tokens;

    public ParserException(String message) {
        super(message);
    }

    public ParserException(String message, Token...contexts) {
        super(message);
        this.tokens = contexts;
    }

    public Token[] getCausalTokens() {
        return this.tokens;
    }

}

/**
 * Parses tokens.
 *
 * @author Sean Johnson <isr830@my.utsa.edu>
 */
public class Parser {

    /**
     * Checks the primary and subclass type of the given token.
     *
     * @param Token t token to check
     * @param Primary p primary class
     * @param Subclass s subclass
     *
     * @return boolean
     */
    static boolean tokenType(Token t, Primary p, Subclass s) {
        if ( p == null ) p = Primary.UNKNOWN;
        if ( s == null ) s = Subclass.UNKNOWN;

        return t.primClassif == p.getCid() && t.subClassif == s.getCid();
    }

    /*
     * List of tokens passed from the language entry stub.
     * Should be generated by the Scanner.
     */
    private List<Token> tokens;

    public Parser(List<Token> tokens) {
        this.tokens = tokens;
    }

    // ERROR MANGLEMENT

    /**
     * Creates and throws a ParserException with a set of context passed
     * from parser blocks.
     *
     * @param String message
     * @param Token[] contexts
     *
     * @return void
     *
     * @throws ParserException
     */
    static void reportParseError(String message, Token...contexts) throws ParserException {
        String[] contextStr = new String[contexts.length];

        for (int i = 0; i < contextStr.length; i++) {
            Token t = contexts[i];
            if ( t != null ) {
                contextStr[i] = String.format(
                        "[%s:%d:%d]: Near token `%s`",
                        Scanner.getInstance().sourceFileNm,
                        t.iSourceLineNr,
                        t.iColPos,
                        t.tokenStr
                );
            } else {
                contextStr[i] = "[invalid] Null token given to error reporter";
            }
        }

        StringBuilder excSb = new StringBuilder();

        for (String s : contextStr) {
            excSb.append(s + "\n");
        }

        throw new ParserException(
                String.format(
                    "Parse error occurred: %s\n%s",
                    message,
                    excSb
                ),
                contexts
        );
    }

    // TOKEN MANGLEMENT

    /**
     * Check the string value of the next token.
     *
     * @param String s
     *
     * @return boolean
     */
    private boolean isNext(String s) {
        return this.isNext(this.tokens, s);
    }

    /**
     * Check the string value of the next token inside the token subset in `t`.
     *
     * @param List<Token> t
     * @param String s
     *
     * @return boolean
     */
    private boolean isNext(List<Token> t, String s) {
        if ( this.peekNext(t).tokenStr.equals(s) ) {
            return true;
        }

        return false;
    }

    /**
     * Forces the parser to eat the next token.
     *
     * @return void
     */
    private void eatNext() {
        this.tokens.remove(0);
    }

    /**
     * Forces the parser to eat the next token from the token subset in `l`.
     *
     * @return void
     */
    private void eatNext(List<Token> l) {
        l.remove(0);
    }

    /**
     * Forces the parser to eat the next token if the token's primary and
     * sub classes match the given type.
     *
     * @param Primary prim
     * @param Subclass sub
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfOfType(Primary prim, Subclass sub) {
        return this.eatNextIfOfType(this.tokens, prim, sub);
    }

    /**
     * Forces the parser to eat the next token from the token subset at `l`
     * if the token's primary and sub classes match the given type.
     *
     * @param List<Token> l
     * @param Primary prim
     * @param Subclass sub
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfOfType(List<Token> l, Primary prim, Subclass sub) {
        if ( tokenType(this.peekNext(l), prim, sub) ) {
            this.eatNext(l);
            return true;
        }

        return false;
    }

    /**
     * Forces the parser to eat the next token if the token's string value
     * matches the given string value.
     *
     * @param String s
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfEq(String s) {
        return this.eatNextIfEq(this.tokens, s);
    }

    /**
     * Forces the parser to eat the next token from the token subset at `l`
     * if the token's string value matches the given string value.
     *
     * @param List<Token> l
     * @param String s
     *
     * @return boolean token was eaten?
     */
    private boolean eatNextIfEq(List<Token> l, String s) {
        if ( this.isNext(l, s) ) {
            this.eatNext(l);
            return true;
        }

        return false;
    }

    /**
     * Pops the next token off the array.
     *
     * @return Token
     */
    private Token popNext() {
        return this.tokens.remove(0);
    }

    private Token popNext(List<Token> l) {
        return l.remove(0);
    }

    /**
     * Allows for single lookahead of the next token without popping.
     *
     * @return Token
     */
    private Token peekNext() {
        try {
            return this.tokens.get(0);
        } catch (IndexOutOfBoundsException ex) {
            return null;
        }
    }

    private Token peekNext(List<Token> l) {
        try {
            return l.get(0);
        } catch (IndexOutOfBoundsException ex) {
            return null;
        }
    }

    /**
     * Gets and returns a list of tokens up to statement end.
     *
     * @return List<Token>
     */
    private List<Token> popStatement() {
        return this.popStatement(this.tokens);
    }

    /**
     * Gets and returns a list of tokens up to statement end.
     *
     * @return List<Token>
     */
    private List<Token> popStatement(List<Token> tokens) {
        List<Token> newTokens = this.popUntil(tokens, ";");

        this.eatNext();

        return newTokens;
    }

    /**
     * Gets and returns a list of tokens up to the next delimiter.
     *
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntil(String delim) {
        return this.popUntil(this.tokens, delim);
    }

    /**
     * Gets and returns a list of tokens up to the next delimiter.
     *
     * @param List<Token> tokens
     * @param String delim
     *
     * @return List<Token>
     */
    private List<Token> popUntil(List<Token> tokens, String delim) {
        List<Token> newTokens = new ArrayList<>();

        while ( ! this.peekNext(tokens).tokenStr.equals(delim) ) {
            newTokens.add(this.popNext(tokens));
        }

        return newTokens;
    }

    /**
     * Gets and returns a list of tokens up to the next set of delimiters.
     *
     * @param String delims
     *
     * @return List<Token>
     */
    private List<Token> popUntil(String...delims) {
        return this.popUntil(this.tokens, delims);
    }

    /**
     * Gets and returns a list of tokens up to the next set of delimiters.
     *
     * @param List<Token> tokens
     * @param String delims
     *
     * @return List<Token>
     */
    private List<Token> popUntil(List<Token> tokens, String...delims) {
        List<Token> newTokens = new ArrayList<>();

        List<String> delimsList = Arrays.asList(delims);

        while ( ! delimsList.contains(this.peekNext(tokens).tokenStr) ) {
            newTokens.add(this.popNext(tokens));
        }

        return newTokens;
    }

    // PARSER MANGLEMENT

    /**
     * Returns if the parser's internal token list is empty or not.
     *
     * @return boolean
     */
    public boolean canParse() {
        return this.canParse(this.tokens);
    }

    public boolean canParse(List<Token> tokens) {
        return !tokens.isEmpty();
    }

    /**
     * Public parsing entrypoint. Returns a single parsed statement
     * in a mini-AST form.
     *
     * @return Statement
     *
     * @throws ParserException
     */
    public Statement parse() throws ParserException {
        Token t = this.peekNext();

        Expression expr = null;
        switch (Primary.primaryFromInt(t.primClassif)) {
            case CONTROL:
                return this.parseControl(t);
            case OPERAND:
                expr = this.parseExpression(this.popStatement());
                if ( !expr.isValid() ) {
                    // Expr not valid?
                    return null;
                }
                return new Statement(expr);
            case FUNCTION:
                FunctionCall funcCall = this.parseFunctionCall(this.popStatement());
                if ( !funcCall.isValid() ) {
                    // Function call not valid?
                    return null;
                }

                // Up-resolve to expression
                expr = new Expression(funcCall);
                if ( !expr.isValid() ) {
                    // ..
                    return null;
                }

                return new Statement(expr);
            case SEPARATOR:
                return null;
            default:
                reportParseError(
                        "Could not further derive statement",
                        t
                );
                return null;
        }
    }

    /**
     * Parses a control statement based on the leading token.
     * Allows declarations, "for", "while", "if", and "select",
     * as well as their corresponding "end" statements.
     *
     * @param Token head
     *
     * @return Statement
     *
     * @throws ParserException
     */
    private Statement parseControl(Token head) throws ParserException {
        switch (Subclass.subclassFromInt(head.subClassif)) {
            case FLOW:
                return new Statement(this.parseFlowControl(this.popUntil(":")));
            case END:
                return null;
            case DECLARE:
                this.eatNext();
                return this.parseDeclaration(head);
            default:
                reportParseError(
                        "Failed building control elements",
                        head
                );
                return null;
        }

    }

    /**
     * Parses a full flow control statement until its corresponding end
     * statement.
     *
     * @param List<Token> tokens
     *
     * @return FlowControl
     *
     * @throws ParserException
     */
    private FlowControl parseFlowControl(List<Token> tokens) throws ParserException {
        // At this point, the next token should be the flow delimiter.
        this.eatNextIfEq(":");

        Token flowT = this.popNext(tokens);

        Expression cond;
        Block mainBranch;
        switch (flowT.tokenStr) {
            case "if":
                cond = this.parseExpression(tokens);
                mainBranch = this.parseBlock("else", "endif");
                Block elseBranch = null;

                if ( this.isNext("else") ) {
                    this.eatNext();
                    this.eatNextIfEq(":");
                    elseBranch = this.parseBlock("endif");
                }

                if ( ! this.eatNextIfEq("endif") ) {
                    reportParseError(
                            "If statement has no matching endif",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                IfControl ifStmt = new IfControl(cond, mainBranch, elseBranch);
                return new FlowControl(ifStmt);
            case "while":
                cond = this.parseExpression(tokens);
                mainBranch = this.parseBlock("endwhile");

                if ( ! this.eatNextIfEq("endwhile") ) {
                    reportParseError(
                            "While statement has no matching endwhile",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                WhileControl whileStmt = new WhileControl(cond, mainBranch);
                return new FlowControl(whileStmt);
            case "for":
                Expression expr = this.parseExpression(tokens);

                Block forBody = this.parseBlock("endfor");
                if ( ! this.eatNextIfEq("endfor") ) {
                    reportParseError(
                            "While statement has no matching endfor",
                            flowT
                    );
                    return null;
                } else {
                    if ( ! this.eatNextIfEq(";") ) {
                        reportParseError(
                                "Unterminated end-statement",
                                flowT
                        );
                        return null;
                    }
                }

                ForControl forStmt = new ForControl(expr, forBody);
                return new FlowControl(forStmt);
            case "select":
                // do the thing
                break;
            default:
                // wat
                reportParseError(
                        "Invalid control flow token",
                        flowT
                );
                return null;
        }

        reportParseError(
                "Flow control parser fell out of case",
                flowT
        );
        return null;
    }

    /**
     * Parses a declaration given the starting datatype token.
     *
     * @param Token head
     *
     * @return Statement
     *
     * @throws ParserException
     */
    private Statement parseDeclaration(Token head) throws ParserException {
        List<Token> tokens = this.popStatement();

        if ( tokenType(head, Primary.CONTROL, Subclass.DECLARE) &&
             tokenType(this.peekNext(tokens), Primary.SEPARATOR, null) ) {

            tokens.add(0, head);
            Statement st = this.parseArrayDecl(tokens);
            if ( st.isValid() ) {
                return st;
            } else {
                reportParseError(
                        "Array declaration is invalid",
                        head
                );
                return null;
            }
        } else if ( tokenType(head, Primary.CONTROL, Subclass.DECLARE) &&
                    tokenType(this.peekNext(tokens), Primary.OPERAND, Subclass.IDENTIFIER) ) {

            DataType dt = new DataType(head);

            Token next = this.popNext(tokens);

            Identifier ident = new Identifier(next);
            Declaration decl = new Declaration(dt, ident);

            // Peek at the next token to see if this is a compound declaration
            Token oper = this.peekNext(tokens);
            if ( oper != null && oper.tokenStr.equals("=") ) {
                tokens.add(0, next);
                tokens.add(0, head);
                return new Statement(this.parseComplexDeclaration(tokens));
            }

            if ( dt.isValid() && ident.isValid() && decl.isValid() ) {
                return new Statement(decl);
            } else {
                reportParseError(
                        "Declaration is invalid",
                        head,
                        next,
                        oper
                );
                return null;
            }
        } else {
            reportParseError(
                    "Declaration is invalid",
                    head
            );
            return null;
        }
    }

    /**
     * Parses a "complex" declaration. A complex declaration is a compound
     * declaration and assignment statement.
     *
     * Example:
     *
     *      {@code Int i = 50;}
     *
     * @param List<Token> tokens
     *
     * @return Assignment
     *
     * @throws ParserException
     */
    private Assignment parseComplexDeclaration(List<Token> tokens) throws ParserException {
        Token typeT = this.popNext(tokens);
        Token identT = this.popNext(tokens);

        DataType dtype = new DataType(typeT);
        Identifier ident = new Identifier(identT);
        Declaration decl = new Declaration(dtype, ident);

        Token operatorT = this.popNext(tokens);
        Operator oper = null;

        if ( tokenType(operatorT, Primary.OPERATOR, null) && operatorT.tokenStr.equals("=") ) {
            oper = new Operator(operatorT);
        }

        Expression expr = this.parseExpression(tokens);

        Assignment a = new Assignment(decl, oper, expr);
        if ( a == null || !a.isValid() ) {
            reportParseError(
                    "Declaration is invalid",
                    typeT,
                    identT,
                    operatorT
            );
            return null;
        }

        return a;
    }

    /**
     * Parses a compound array declaration which may or may not include an assignment.
     *
     * Example:
     *
     *      {@code Int[] ary = 1, 2, 3, 4, 5;}
     *
     * @param List<Token> tokens
     *
     * @return Statement
     *
     * @throws ParserException
     */
    private Statement parseArrayDecl(List<Token> tokens) throws ParserException {
        // Try to parse into a array assignment, otherwise, explode.
        Token head = this.popNext(tokens);

        if ( ! this.eatNextIfEq(tokens, "[") ) {
            reportParseError(
                    "Invalid following separator - use `[]` to create an array",
                    head,
                    this.peekNext(tokens)
            );
            return null;
        }

        // Now the next token should be a primitive (int), but if it is empty (next token is ']')
        // then this is an unbounded array.
        DataType dt = new DataType(head);
        int arySize = -1;

        if ( ! this.eatNextIfEq(tokens, "]") ) {
            // Something within the brackets
            if ( ! this.tokenType(this.peekNext(tokens), Primary.OPERAND, Subclass.INTEGER) ) {
                reportParseError(
                        String.format(
                            "Unexpected token `%s`, expected Integer primitive",
                            this.peekNext(tokens).tokenStr
                        ),
                        head,
                        this.peekNext(tokens)
                );
            } else {
                Token t = this.popNext(tokens);
                arySize = Numerics.tokenAsInt(t);

                if ( ! this.eatNextIfEq(tokens, "]") ) {
                    reportParseError(
                            String.format(
                                "Unexpected token `%s` after array size, expected `]`",
                                this.peekNext(tokens).tokenStr
                            ),
                            head,
                            t,
                            this.peekNext(tokens)
                    );
                }
            }
        }

        Token identT = this.popNext(tokens);
        Identifier ident = new Identifier(identT);
        Declaration dec = new Declaration(dt, ident, true, arySize);
        Expression value;

        // Peek at the next token to see if this is a compound declaration
        Token operT = this.peekNext(tokens);
        if ( operT == null ) {
            // End of declaration
            return new Statement(dec);
        }

        // Otherwise, check for a compound array declaration
        if ( this.eatNextIfEq(tokens, "=") ) {
            value = this.parseExpression(tokens);
            Assignment a = new Assignment(dec, new Operator(operT), value);
            if ( a.isValid() ) {
                return new Statement(a);
            } else {
                reportParseError(
                        "Assignment statement not valid",
                        head,
                        identT,
                        operT
                );
                return null;
            }
        } else {
            if ( dec.isValid() ) {
                return new Statement(dec);
            } else {
                reportParseError(
                        "Declaration not valid",
                        head,
                        identT
                );
                return null;
            }
        }
    }

    /**
     * Parses a function call plus the arguments, which get reduced to
     * individual `Expression`s.
     *
     * @param List<Token> tokens
     *
     * @return FunctionCall
     *
     * @throws ParserException
     */
    private FunctionCall parseFunctionCall(List<Token> tokens) throws ParserException {
        Token handle = this.popNext(tokens);

        Identifier funcName = new Identifier(handle);
        if ( !funcName.isValid() ) {
            reportParseError(
                    "Bad function handle",
                    handle
            );
            return null;
        }

        Token openParen = this.popNext(tokens);
        if ( tokenType(openParen, Primary.SEPARATOR, null) && openParen.tokenStr.equals("(") ) {
            Token t;
            List<Expression> argsList = new ArrayList<>();
            List<Token> argTokens = new ArrayList<>();

            while ((t = this.popNext(tokens)) != null) {
                if ( t.tokenStr.equals(")") ) {
                    // Flush all tokens through `parseExpression` and add to `argsList`
                    argsList.add(this.parseExpression(argTokens));

                    // Clear out argTokens
                    argTokens = new ArrayList<>();

                    break;
                }

                switch (t.tokenStr) {
                    case ",":
                        // Flush all tokens through `parseExpression` and add to `argsList`
                        argsList.add(this.parseExpression(argTokens));

                        // Clear out argTokens
                        argTokens = new ArrayList<>();

                        break;
                    default:
                        argTokens.add(t);
                        break;
                }
            }

            FunctionCall fCall = new FunctionCall(funcName, argsList);
            if ( !fCall.isValid() ) {
                reportParseError(
                        "Invalid function call",
                        handle,
                        openParen,
                        t
                );
                return null;
            }

            return fCall;
        }

        return null;
    }

    /**
     * Parse a block from the parser's token list. Will parse up to
     * delimiter(s) given in `...until`.
     *
     * @param String[] until
     *
     * @return Block
     *
     * @throws ParserException
     */
    private Block parseBlock(String...until) throws ParserException {
        return this.parseBlock(this.tokens, until);
    }

    /**
     * Parse a block from an arbitrary token list. Will parse up to
     * delimiter(s) given in `...until`.
     *
     * @param String[] until
     *
     * @return Block
     *
     * @throws ParserException
     */
    private Block parseBlock(List<Token> tokens, String...until) throws ParserException {
        List<String> delim = Arrays.asList(until);
        List<Statement> stmts = new ArrayList<>();

        while ( ! delim.contains(this.peekNext(tokens).tokenStr) ) {
            Statement s = this.parse();
            if ( s == null ) {
                reportParseError(
                        "Block parser encountered a null statement",
                        this.peekNext(tokens)
                );
                break;
            }
            stmts.add(s);
        }

        return new Block(stmts);
    }

    /**
     * Parses an expression from a list of tokens. Most general case token
     * reduction available underneath `Statement`.
     *
     * @param List<Token> arg
     *
     * @return Expression
     *
     * @throws ParserException
     */
    private Expression parseExpression(List<Token> arg) throws ParserException {
        if ( arg.isEmpty() ) {
            reportParseError("Expression parsing failed!");
            return null;
        }

        Token head = this.popNext(arg);
        if ( arg.isEmpty() ) {
            return new Expression(head);
        }

        Token next = this.peekNext(arg);

        switch (Primary.primaryFromInt(head.primClassif)) {
            case OPERAND:
                if ( next.primClassif == Primary.OPERATOR.getCid() ) {
                    Expression lhs = new Expression(head);
                    Operator oper = new Operator(this.popNext(arg));

                    Expression rhs = this.parseExpression(arg);
                    BinaryOperation binOp = new BinaryOperation(lhs, oper, rhs);

                    if ( next.tokenStr.equals("=") ) {
                        // binOp is an assignment
                        Assignment a = new Assignment(binOp);
                        if ( ! a.isValid() ) {
                            reportParseError(
                                    "Building assignment failed",
                                    head,
                                    next
                            );
                            return null;
                        }

                        return new Expression(a);
                    } else {
                        if ( ! binOp.isValid() ) {
                            reportParseError(
                                    "Building binary operation failed",
                                    head,
                                    next
                            );
                            return null;
                        }

                        return new Expression(binOp);
                    }
                } else if ( next.primClassif == Primary.SEPARATOR.getCid() ) {
                    switch (next.tokenStr) {
                        case ",":  // Array notation
                            Array ary = new Array();
                            ary.addItem(new Primitive(head));

                            while ( this.canParse(arg) ) {
                                Token t = this.popNext(arg);
                                switch (Primary.primaryFromInt(t.primClassif)) {
                                    case OPERAND:
                                        ary.addItem(new Primitive(t));
                                        break;
                                    case SEPARATOR:
                                        continue;
                                    default:
                                        reportParseError(
                                                "Invalid token in array construct",
                                                t
                                        );
                                        return null;
                                }
                            }

                            return new Expression(ary);
                        case "[":  // subscripted identifier
                            // eat the first token since it is the subscript open bracket
                            this.eatNext(arg);

                            // first upcoming token should be some sort of expression
                            // the next delimiter token (`:`) will mark the end of the begin expression
                            // of the subscript
                            Subscript sub;

                            List<Token> exprBeginPartT = this.popUntil(arg, ":", "]");
                            Expression exprBegin = this.parseExpression(exprBeginPartT);

                            List<Token> exprEndPartT;
                            Expression exprEnd = null;

                            // Depending on the next token, we can create the subscript to attach
                            // to the identifier.
                            if ( this.eatNextIfEq(arg, ":") ) {
                                // There's an end part of the subscript!
                                exprEndPartT = this.popUntil(arg, "]");
                                exprEnd = this.parseExpression(exprEndPartT);
                            }

                            if ( this.eatNextIfEq(arg, "]") ) {
                                // Finish the subscript
                                sub = new Subscript(exprBegin, exprEnd);
                                Identifier i = new Identifier(head, sub);
                                if ( i.isValid() ) {
                                    Expression lhs = new Expression(i);

                                    if ( ! this.canParse(arg) ) {
                                        return lhs;
                                    }

                                    Token operT = this.popNext(arg);
                                    Operator oper = new Operator(operT);

                                    Expression rhs = this.parseExpression(arg);
                                    BinaryOperation binOp = new BinaryOperation(lhs, oper, rhs);

                                    if ( operT.tokenStr.equals("=") ) {
                                        // binOp is an assignment
                                        Assignment a = new Assignment(binOp);
                                        if ( ! a.isValid() ) {
                                            reportParseError(
                                                    "Building assignment failed",
                                                    head,
                                                    next
                                            );
                                            return null;
                                        }

                                        return new Expression(a);
                                    } else {
                                        if ( ! binOp.isValid() ) {
                                            reportParseError(
                                                    "Building binary operation failed",
                                                    head,
                                                    next
                                            );
                                            return null;
                                        }

                                        return new Expression(binOp);
                                    }
                                } else {
                                    reportParseError(
                                            "Identifier is not valid",
                                            head,
                                            next
                                    );
                                    return null;
                                }
                            } else {
                                reportParseError(
                                        String.format(
                                            "Unexpected token `%s`, expected `]`",
                                            this.peekNext(arg)
                                        ),
                                        head,
                                        next
                                );
                                return null;
                            }
                        case "(":  // function call..
                            // this should be a function call since an open paren follows it.
                            // reclassify the head token and build the function call.
                            //
                            // Since it was not recognized by the Scanner as a function call,
                            // it *has* to be a user defined function.
                            head.primClassif = Primary.FUNCTION.getCid();
                            head.subClassif = Subclass.USER.getCid();

                            // Re-call parseExpression to parse the newly known function call!
                            arg.add(0, head);

                            return this.parseExpression(arg);
                        default:
                            break; // doot doot
                    }
                }

                break;
            case FUNCTION:
                arg.add(0, head);
                FunctionCall fCall = this.parseFunctionCall(arg);

                if ( ! fCall.isValid() ) {
                    reportParseError(
                            "Building function call in from expression failed",
                            head,
                            next
                    );
                    return null;
                }

                return new Expression(fCall);
            default:
                reportParseError(
                        "Building expression failed",
                        head,
                        next
                );
                return null;
        }

        reportParseError(
                "Expression parser fell out of switch, bailing out",
                head,
                next
        );

        return null;
    }
}
